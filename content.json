{"meta":{"title":"jzq's blog","subtitle":null,"description":null,"author":"Jiang zq","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"模拟法不模拟","slug":"模拟法不模拟","date":"2020-02-17T14:06:15.000Z","updated":"2020-02-17T14:23:53.051Z","comments":true,"path":"2020/02/17/模拟法不模拟/","link":"","permalink":"http://yoursite.com/2020/02/17/%E6%A8%A1%E6%8B%9F%E6%B3%95%E4%B8%8D%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"拒绝傻瓜模拟发现自己对模拟这种最基础的解题方法使用的出了点问题，模拟的本意应是按题意直接编写程序，而我却把模拟使用成了，从问题的起始，一直往后推到结束，这种思路在一些题上是正确的，但是在一些题目上会发现中间的过程过于的复杂，用程序来模拟不现实，此时就应该考虑从大局上来思考问题。 eg：https://codeforces.com/contest/1304/problem/C 此题我能想到的解法便是从头开始推，每次都能满足条件且更接近下个顾客的舒适温度，类似与贪心的思想，但仔细想来根本实现不了，中间可执行的操作太多了，每一分钟可有3种操作。这时候，我们不妨从大体上来看，我们将一段时间温度可以调控到的温度设为一个区间，当顾客的舒适温度区间与能调控的区间有相交的话，便能满足条件。 附代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+50;struct customers&#123; ll t,l,r; &#125;s[150];int main()&#123; ll t; scanf(&quot;%lld&quot;,&amp;t); while(t--) &#123; ll n,m,ans=0,left,right,flag=0; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;s[i].t,&amp;s[i].l,&amp;s[i].r); left=right=m; for(int i=0;i&lt;n;i++) &#123; ll x=s[i].t-ans; left-=x; right+=x; if(right&lt;s[i].l||left&gt;s[i].r) &#123; flag=1; break; &#125; if(left&lt;s[i].l) left=s[i].l; if(right&gt;s[i].r) right=s[i].r; ans=s[i].t; &#125; if(flag) puts(&quot;NO&quot;); else puts(&quot;Yes&quot;); &#125; return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++的string","slug":"C-的string","date":"2020-02-17T02:56:23.000Z","updated":"2020-02-17T14:26:02.679Z","comments":true,"path":"2020/02/17/C-的string/","link":"","permalink":"http://yoursite.com/2020/02/17/C-%E7%9A%84string/","excerpt":"","text":"论string的重要性初次知道string时并没有将它放在心上，我觉得使用字符数组就够了，这让我在算法竞赛中吃了大亏。 使用string的优点1：快捷，所有的操作都无需再用复杂的cstring函数库，可直接使用&gt;,&lt;,==,=等符号 2：可直接利用sort使string数组按字典序从小到大排序，也可自定义规则 3：在某些题目上可与map相关联使用会有出其不意的效果。 4：不必担心内存是否足够 eg：https://atcoder.jp/contests/abc155/tasks/abc155_c Problem Statement We have N voting papers. Thei-th vote(1≤i≤N) has the stringSi written on it. Print all strings that are written on the most number of votes, in lexicographical order. Constraints1≤N≤2×105Si (1≤i≤N) are strings consisting of lowercase English letters.The length ofSi (1≤i≤N) is between1 and10 (inclusive). InputInput is given from Standard Input in the following format: N S1 : SN Output Print all strings in question in lexicographical order.附代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define INF 0x3f3f3f3f;using namespace std;string s[200005];int main() &#123; int n,i; scanf(&quot;%d&quot;,&amp;n); for(i=0; i&lt;n; i++) cin&gt;&gt;s[i]; sort(s,s+n); int m=1,cnt=1; for(i=1; i&lt;n; i++) &#123; if(s[i]==(s[i-1])) cnt++; else cnt=1; m=max(cnt,m); &#125; cnt=1; if(m==1) cout&lt;&lt;s[0]&lt;&lt;endl; for(i=1; i&lt;n; i++) &#123; if(s[i]==(s[i-1])) cnt++; else cnt=1; if(cnt==m) cout&lt;&lt;s[i]&lt;&lt;endl; &#125;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"基数排序Or贪心","slug":"基数排序Or贪心","date":"2020-02-03T08:44:46.000Z","updated":"2020-02-03T09:41:39.307Z","comments":true,"path":"2020/02/03/基数排序Or贪心/","link":"","permalink":"http://yoursite.com/2020/02/03/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8FOr%E8%B4%AA%E5%BF%83/","excerpt":"","text":"基数排序中的贪心思想什么是基数排序？先来看看它的实现：从个位到最高位依次排序一次，到最后的时候该数组有序。我们可以这么理解，一个数 = 个位+十位10+百位100+千位*1000…当比较大小时如果我们这样去想，我们先保证个位的有序度，再保证十位的有序度，再保证百位的有序度…依次往后延伸，这样在最后整个数组都会是有序的。贪心算法是局部最优带来整体最优，基数排序这里也一样，从局部的个位有序，十位有序，百位有序，一直到整体有序。 附上C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;void radiosort(int arr[],int n)&#123; int max = arr[0]; int i; for(i=1;i&lt;n;i++) if(arr[i]&gt;max)max=arr[i]; int num = 1;///计算最大值是几位数。 while(max/10&gt;0)///这样不用对0再讨论 &#123; num++; max/=10; &#125; int bucket[10][20]=&#123;0&#125;; ///进行每一趟的排序，从个位数开始排 for( i = 1 ;i&lt;=num;i++) &#123; for(int j=0;j&lt;n;j++) &#123; int index=(arr[j]/(int)pow(10,i-1))%10; for(int k = 0; k &lt; 20; k++) &#123; if(bucket[index][k] == 0) &#123; bucket[index][k] = arr[j]; break; &#125; &#125; &#125; ///合并放入原数组,此处放回的规则应该是先进先出，后进后出 int t=0; for(int j=0;j&lt;10;j++) &#123; for(int k = 0; k &lt; 20; k++) &#123; if(bucket[j][k] != 0) &#123; arr[t++]=bucket[j][k]; bucket[j][k]=0; &#125; else break; &#125; &#125; &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int arr[n]; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;arr[i]); radiosort(arr,n); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,arr[i]); return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"有关尺取法的深度思考","slug":"有关尺取法的深度思考","date":"2020-01-16T03:23:12.000Z","updated":"2020-01-16T04:03:10.535Z","comments":true,"path":"2020/01/16/有关尺取法的深度思考/","link":"","permalink":"http://yoursite.com/2020/01/16/%E6%9C%89%E5%85%B3%E5%B0%BA%E5%8F%96%E6%B3%95%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83/","excerpt":"","text":"题目：链接：https://ac.nowcoder.com/acm/contest/3570/B来源：牛客网 “一刀建林流泪，两刀马云都得跪。”摆在你面前的一长条切糕，你想尝到切糕里面所有的果仁，什么核桃呀，杏仁呀，巴旦木呀…但因为切糕很贵，你要选取一段连续的切糕，使得你能吃到这份切糕里所有的果仁，切记切糕贵，所以要选取最短的长度并且要包含所有的果仁，这里的果仁可以简单的看做a果仁，b果仁，c果仁….，输出能包含所有果仁的最短长度。换句话说出现的果仁都要出现在你所选的区间里面，输出这个区间的最短长度。 输入描述:第一行包含整数n(1≤n≤100 000)——切糕的长度。第二行包含长度为n的字符串，它由英文字母表中的大写字母和小写字母组成。输出描述:输出一个整数，表示最小选取的长度。 本人之前对尺取法的理解很是浅显，只知道先扩大右端点，再改变左端点。但对于具体的思路很难想到。 关键：将区间一直改变，让它一直满足题目所给的要求，但是让区间不在改变的条件很关键，本题的这个关键就是左端点的字母在左端点以后都没有出现过。（是左端点以后而不是选择的区间里面，因为会出现如abbcccccabc的情况） 设满足题意即只要能让所有的字母出现至少一次的条件是a，该区间最短为b。我们首先将区间左右端点都设为0，扩大右端点，当所有字母都出现后停止扩大，b即为该区间长度，此时右端点有可能在总区间的各个位置，然后我们扩大左端点，从现在的左端点位置进行判断，如果这个左端点在选择的区间中出现了不止一次，那么直接扩大左端点，无需其他任何操作。如果这个左端点只出现了一次，我们假设去掉它，再扩大右端点，如果在此时的右端点以后的各个字母已经没有该个被删去的字母，那么最优解已经找到；如果在此时的右端点以后的各个字母还有该个被删去的左端点，那么现在的区间即为【被删去的左端点+1，右端点后的下一个该字母】，这时，我们判断这个新区间与原来那个最短区间b的大小，选择最优解。此后将以上过程循环，直到删去左端点时右端点以后找不到该字母。 12345678910111213141516171819202122232425262728293031323334include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int n,temp=0,i,ans;char s[100010];int a[200]; memset(a,0,sizeof(a)); scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s); for(i=0;i&lt;n;i++) &#123; a[s[i]]=1; &#125; for(i=65;i&lt;=122;i++) if(a[i]) temp++; memset(a,0,sizeof(a)); int l=0,r=0,now=1;ans=n+1; a[s[l]]=1; while(1) &#123; while(r&lt;n-1) &#123; if(now==temp) break; r++; if(!a[s[r]]) &#123;now++;&#125; a[s[r]]++; &#125; if(now&lt;temp) break;//左边的端点去后，在之后再也找不到了。 if(r-l+1&lt;ans) ans=r-l+1;//ans等于选择的区间长度，最大为n if((--a[s[l]])==0) now--;//从左端点开始判断其是否在选择的区间中只出现了1次 l++; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"倍增的思想","slug":"倍增的思想","date":"2019-12-24T08:09:43.000Z","updated":"2019-12-24T08:12:18.118Z","comments":true,"path":"2019/12/24/倍增的思想/","link":"","permalink":"http://yoursite.com/2019/12/24/%E5%80%8D%E5%A2%9E%E7%9A%84%E6%80%9D%E6%83%B3/","excerpt":"","text":"题目：P1909 买铅笔P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有 33种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P老师决定只买同一种包装的铅笔。 商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过nn支铅笔才够给小朋 友们发礼物。 现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少nn支铅笔最少需要花费多少钱。 输入格式第一行包含一个正整数nn，表示需要的铅笔数量。 接下来三行，每行用22个正整数描述一种包装的铅笔：其中第11个整数表示这种 包装内铅笔的数量，第22个整数表示这种包装的价格。 保证所有的77个数都是不超过1000010000的正整数。此题是一个简单的模拟，可运用倍增的思想，能大幅度减少运算时间。 #include&lt;cstdio&gt; using namespace std; int i,j,k,n,m,w,ans; int main() { scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;3;i++){ scanf(&quot;%d%d&quot;,&amp;j,&amp;k);m=j;w=k;//输入并存下初始的价格与数量 while(j&lt;n){j&lt;&lt;=1;k&lt;&lt;=1;}//价格与数量不断*2直到数量大于n while(j&gt;n){j-=m;k-=w;}//*2有可能导致买太多了，减去一些 while(j&lt;n){j+=m;k+=w;}//减去之后又可能太少了，加上一些 //其实就是大幅度地上调，然后做一些微调 if(k&lt;ans||ans==0)ans=k;//判断是否是最小花费 } printf(&quot;%d\\n&quot;,ans); return 0;//输出并返回 }","categories":[],"tags":[]},{"title":"由于未初始化导致的本地运行和oj运行答案不一致","slug":"由于未初始化导致的本地运行和oj运行答案不一致","date":"2019-11-19T09:08:22.732Z","updated":"2020-01-16T04:07:28.207Z","comments":true,"path":"2019/11/19/由于未初始化导致的本地运行和oj运行答案不一致/","link":"","permalink":"http://yoursite.com/2019/11/19/%E7%94%B1%E4%BA%8E%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E5%92%8Coj%E8%BF%90%E8%A1%8C%E7%AD%94%E6%A1%88%E4%B8%8D%E4%B8%80%E8%87%B4/","excerpt":"","text":"title: ‘[由于未初始化导致的本地运行和oj运行答案不一致]’date: 2019-11-19 17:08:22tags: 算法 题目：本题要求实现一个函数，用下列公式求cos的近似值，精确到最后一项的绝对值小于e：cos(x)=x0/0!−x2/2!+x4/4!−x6/6!+⋯函数接口定义：double funcos( double e, double x );其中用户传入的参数为误差上限e和自变量x；函数funcos应返回用给定公式计算出来、并且满足误差要求的cos的近似值。输入输出均在双精度范围内。错误代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;math.h&gt;double funcos( double e, double x )&#123; double s=0,t; int i=0,j,flag=1; while(fabs(t)&gt;=e) &#123; t=pow(x,i); for(j=1;j&lt;=i;j++) &#123; t/=j; &#125; s+=t*flag; flag=-flag; i+=2; &#125; return s;&#125;int main()&#123; double e, x; scanf(&quot;%lf %lf&quot;, &amp;e, &amp;x); printf(&quot;cos(%.2f) = %.6f\\n&quot;, x, funcos(e, x)); return 0;&#125; 正确代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;math.h&gt;double funcos( double e, double x )&#123; double s=0,t=0; int i=0,j,flag=1; while(fabs(t)&gt;=e) &#123; t=pow(x,i); for(j=1;j&lt;=i;j++) &#123; t/=j; &#125; s+=t*flag; flag=-flag; i+=2; &#125; return s;&#125;int main()&#123; double e, x; scanf(&quot;%lf %lf&quot;, &amp;e, &amp;x); printf(&quot;cos(%.2f) = %.6f\\n&quot;, x, funcos(e, x)); return 0;&#125; 分析：第一次错误代码再本地运行时能输出正确答案，当在oj上运行时却输出0.000000.而第二次与第一次的区别仅仅是将t赋值为0，第一次未赋值，在本地能输出是因为巧合，刚好t的值能进入循环，而在oj上却没有这种巧合，所以直接连循环都没有进入，直接输出s的初始值0.00000。","categories":[],"tags":[]},{"title":"除数，判断俩个数字的各个数字是否有重复的","slug":"除数，判断俩个数字的各个数字是否有重复的","date":"2019-11-11T12:39:26.343Z","updated":"2020-01-16T04:06:14.135Z","comments":true,"path":"2019/11/11/除数，判断俩个数字的各个数字是否有重复的/","link":"","permalink":"http://yoursite.com/2019/11/11/%E9%99%A4%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E4%BF%A9%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E5%90%84%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84/","excerpt":"","text":"title: ‘[除数，判断俩个数字的各个数字是否有重复的]’date: 2019-11-11 20:39:26tags: 算法 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int is(int x,int y)&#123; int a[10]; int i=0,s=0; for(i=0;i&lt;10;i++)a[i]=0;//给数组初始化数值，很重要，一开始没有对就是因为未初始化。 for(i=0;i&lt;5;i++) &#123; a[x%10]=1; a[y%10]=1; x/=10;y/=10; &#125; for(i=0;i&lt;10;i++)s+=a[i]; if(s==10)return 1; return 0;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1234;i&lt;98765;i++)&#123; if(is(i,i*n)==1)printf(&quot;%d/%d=%d\\n&quot;,i*n,i,n); if(i*n&gt;100000)break; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"有关字符串比较函数的拓展","slug":"有关字符串比较函数的拓展","date":"2019-11-10T07:52:48.290Z","updated":"2020-01-16T04:05:33.788Z","comments":true,"path":"2019/11/10/有关字符串比较函数的拓展/","link":"","permalink":"http://yoursite.com/2019/11/10/%E6%9C%89%E5%85%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%8B%93%E5%B1%95/","excerpt":"","text":"title: ‘[有关字符串比较函数的拓展的思考]’date: 2019-11-10 15:52:48tags: 算法题目：如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。例如，abcabc以3为周期（注意，它也以6为周期）。 输入一个长度不超过80的字符串，输出其最小周期。 123456789101112int bijiao(char s1[],int a,int b,char s2[],int c,int d)&#123; int i,j; for(i=a,j=c;i&lt;=b,j&lt;=d;i++,j++) &#123; if (s1[i]&lt;s2[j]||s1[i]&gt;s2[j]) return 0; &#125; return 1;&#125;字符串比较函数，比较函数是否相同，此处不能直接用函数库里的比较字符串函数，因为这个需要在一个字符串中比较其子字符串。 作用：在一个字符串内部比较其不同的子字符串是否相同，而不是选取两个不同字符串进行比较。","categories":[],"tags":[]},{"title":"对于多组输入且每个输入对应一个输出的结果","slug":"对于多组输入且每个输入对应一个输出的结果","date":"2019-11-08T03:13:38.092Z","updated":"2020-01-16T04:08:16.559Z","comments":true,"path":"2019/11/08/对于多组输入且每个输入对应一个输出的结果/","link":"","permalink":"http://yoursite.com/2019/11/08/%E5%AF%B9%E4%BA%8E%E5%A4%9A%E7%BB%84%E8%BE%93%E5%85%A5%E4%B8%94%E6%AF%8F%E4%B8%AA%E8%BE%93%E5%85%A5%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E8%BE%93%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C/","excerpt":"","text":"title: ‘[对于多组输入且每个输入对应一个输出的结果]’date: 2019-11-08 11:13:38tags: 算法 题目：有多组输入(不超过1000组)，每组输入只有1行，包含两个整数l和r(1&lt;=l&lt;=r&lt;=100000)，表示区间范围。对于一个数字n，如果它是偶数则n=n/2，否则n=n*3+1。对于一个区间[l,r]中的数字不停的使用如上操作，直到其等于1为止，问所需操作次数最多的一个数需要多少次操作？”输出：最多的次数为y。每组输入对应输出一行“Case #x: y”，x表示第几组数数据（从1开始编号），y表示结果。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;//算数教室1int main()&#123; int a,b,max=0,j=1; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)&#123; for(int i=a;i&lt;=b;i++)&#123; int flag=0,temp=i; while(temp!=1)&#123; if(temp%2==0)temp/=2;//偶数 else temp=temp*3+1;//奇数 flag++; &#125; if(flag&gt;max)max=flag; &#125; printf(&quot;Case #%d: %d\\n&quot;,j++,max); &#125; return 0;#include&lt;stdio.h&gt;//算数教室2int main()&#123; int a,b,k=1,max; int tab[100001]; for(int i=1;i&lt;=100000;i++)&#123; int flag=0,temp=i; while(temp!=1)&#123; if(temp%2==0)temp/=2;//偶数 else temp=temp*3+1;//奇数 flag++; &#125; tab[i]=flag; &#125; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)&#123; max=0; for(int j=a;j&lt;=b;j++) if(tab[j]&gt;max)max=tab[j]; printf(&quot;Case #%d: %d\\n&quot;,k++,max); &#125; return 0;&#125; 第一次的代码显示时间超限，改进后的第二个代码就没有这个问题了；第二次改进的思路：首先将1到100000的每一个数字所对应的次数算出来，存入一个对应大小的数组其中数字为数组的下标，数组存的值即为每个数字对应的运算次数，然后再根据题目的输入输出，查表求出输入的每一个数字所对应的结果，再根据题目所给的要求将这些值进行运算求解。","categories":[],"tags":[]},{"title":"字符串相关题目","slug":"字符串相关题目","date":"2019-11-04T14:14:55.520Z","updated":"2020-01-16T04:10:31.933Z","comments":true,"path":"2019/11/04/字符串相关题目/","link":"","permalink":"http://yoursite.com/2019/11/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/","excerpt":"","text":"title: ‘[字符串相关题目]’date: 2019-11-04 22:14:55tags: 第一块题目：题目描述编写一程序，用于统计从键盘输入的字符串中的元音字母（a，A，e，E，i，I，o，O，u，U）的个数。输入每行输入一字符串，串长不超过255。输出输出对应字符串中元音字母的个数。样例输入 Copyabcioefgaeioak akkkksd样例输出 Copy352（一开始对题目的输入输出要求理解错误，认为是先输入一堆数据后统一输出，如果这道题像我这样理解的话，则输入应该为一个二维数组，每一行是一个字符串，一行一行的进行计算） 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char ch;int sum; while(scanf(&quot;%c&quot; , &amp;ch) != EOF)/*一直输入直到题目所给文件的末尾，如果手动输入则用 ctrl+z手动结束*/ &#123; if(ch==&apos;a&apos;||ch==&apos;A&apos;||ch==&apos;e&apos;||ch==&apos;E&apos;||ch==&apos;i&apos;||ch==&apos;I&apos;||ch==&apos;o&apos;||ch==&apos;O&apos;||ch==&apos;U&apos;||ch==&apos;u&apos;) sum++; if(ch == &apos;\\n&apos;)&#123;printf(&quot;%d\\n&quot; , sum);sum=0;&#125;//sum记得在每一行的开始清零。 &#125; return 0;&#125; 第二块scanf(%s):遇回车和空格结束。gets()；遇空格才结束。当输入为：a b c d时 c[100];1234567while(scanf(&quot;%s&quot;,c)!=EOF)&#123; printf(&quot;%s&quot;,c);&#125;输出为abcd。char c[100]; while(gets(c)!=EOF)&#123; printf(&quot;%s&quot;,c); &#125; 输出为a b c d。 第三块 对于输入一个值然后将其转化为另一个值，且不是用一个特殊的递归表达式将它计算出来，此时可 以定义一个常量数组，然后每个输入有在该常量数组里的对应的序号，然后用其序号输出。 例题： 把手放在键盘上时，稍不注意就会移动错一位，这样，Q会变成W，输入一个错位后敲出的字符串， 输出打字员本来想打的字符串。输入保证合法，如输入中不会出现 A 。 样例输入： O S, GOMR YPFSU/ 样例输出： I AM FINE TODAY. 12345678910#include&lt;stdio.h&gt;char s[] =&#123; &quot;`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;&apos;ZXCVBNM,./&quot; &#125;int main()&#123; int i ,c; while((c=getchar())!=EOF)&#123; for (i=1; s[i]&amp;&amp; s[i]!=c;i++);//找错位之后的字符在常量表达表中的位置 if(s[i])putchar(s[i-1]);//如果找到，则输出它的前一个字符 else putchar(c); &#125;&#125;","categories":[],"tags":[]},{"title":"水仙花数","slug":"水仙花数","date":"2019-10-31T03:39:01.869Z","updated":"2020-01-16T04:11:11.415Z","comments":true,"path":"2019/10/31/水仙花数/","link":"","permalink":"http://yoursite.com/2019/10/31/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/","excerpt":"","text":"title: “水仙花数一直没有正确输出的原因”date: 2019-10-31 11:39:01tags: 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i,s,a,b; for(i=100;i&lt;1000;i++)&#123; b=i; s=0;//当循环嵌套的时候，在内层循环的开始都应该让判断条件初始化。 while(b)&#123; a=b%10; //printf(&quot;a=%d&quot;,a); s=s+a*a*a; b=b/10; //printf(&quot;b=%d&quot;,b); &#125; //printf(&quot;s=%d\\n&quot;,s); if(s==i)&#123; printf(&quot;%d\\n&quot;,i); &#125;&#125; return 0;&#125;","categories":[],"tags":[]},{"title":"“第一条”","slug":"“第一条”","date":"2019-10-30T14:12:54.430Z","updated":"2020-01-16T04:12:05.725Z","comments":true,"path":"2019/10/30/“第一条”/","link":"","permalink":"http://yoursite.com/2019/10/30/%E2%80%9C%E7%AC%AC%E4%B8%80%E6%9D%A1%E2%80%9D/","excerpt":"","text":"title: “第一条”date: 2019-10-30 22:12:54tags: 这是我的第一条博客，在这里 先记录下由斌哥堂哥分享的有关整数求每个位上数的代码。 1234567891011121314151617181920#include &lt;stdio.h&gt;int main (void)&#123; long long int n; int i = 0, a[1000], j = 0, t = 0; scanf (&quot;%I64d&quot;,&amp;n); if(n==0) printf(&quot;0 &quot;); while (n) &#123; a[j++] = n % 10; n /= 10; &#125; for (i = j - 1; i &gt;= 0; i--) &#123; printf (&quot;%d,&quot;,a[i]);/*将一个整数一个个的通过对10取余和除等于10，依次得到整数的 最后一位数字，将其存入数组，当需要时通过数组的下标一个个取出* &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-30T03:56:53.252Z","updated":"2019-10-30T03:56:53.252Z","comments":true,"path":"2019/10/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}