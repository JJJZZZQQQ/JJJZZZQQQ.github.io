{"meta":{"title":"jzq's blog","subtitle":null,"description":null,"author":"Jiang zq","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"倍增的思想","slug":"倍增的思想","date":"2019-12-24T08:09:43.000Z","updated":"2019-12-24T08:12:18.118Z","comments":true,"path":"2019/12/24/倍增的思想/","link":"","permalink":"http://yoursite.com/2019/12/24/%E5%80%8D%E5%A2%9E%E7%9A%84%E6%80%9D%E6%83%B3/","excerpt":"","text":"题目：P1909 买铅笔P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有 33种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P老师决定只买同一种包装的铅笔。 商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过nn支铅笔才够给小朋 友们发礼物。 现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少nn支铅笔最少需要花费多少钱。 输入格式第一行包含一个正整数nn，表示需要的铅笔数量。 接下来三行，每行用22个正整数描述一种包装的铅笔：其中第11个整数表示这种 包装内铅笔的数量，第22个整数表示这种包装的价格。 保证所有的77个数都是不超过1000010000的正整数。此题是一个简单的模拟，可运用倍增的思想，能大幅度减少运算时间。 #include&lt;cstdio&gt; using namespace std; int i,j,k,n,m,w,ans; int main() { scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;3;i++){ scanf(&quot;%d%d&quot;,&amp;j,&amp;k);m=j;w=k;//输入并存下初始的价格与数量 while(j&lt;n){j&lt;&lt;=1;k&lt;&lt;=1;}//价格与数量不断*2直到数量大于n while(j&gt;n){j-=m;k-=w;}//*2有可能导致买太多了，减去一些 while(j&lt;n){j+=m;k+=w;}//减去之后又可能太少了，加上一些 //其实就是大幅度地上调，然后做一些微调 if(k&lt;ans||ans==0)ans=k;//判断是否是最小花费 } printf(&quot;%d\\n&quot;,ans); return 0;//输出并返回 }","categories":[],"tags":[]},{"title":"由于未初始化导致的本地运行和oj运行答案不一致","slug":"由于未初始化导致的本地运行和oj运行答案不一致","date":"2019-11-19T09:08:22.732Z","updated":"2019-11-19T09:28:48.591Z","comments":true,"path":"2019/11/19/由于未初始化导致的本地运行和oj运行答案不一致/","link":"","permalink":"http://yoursite.com/2019/11/19/%E7%94%B1%E4%BA%8E%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E5%92%8Coj%E8%BF%90%E8%A1%8C%E7%AD%94%E6%A1%88%E4%B8%8D%E4%B8%80%E8%87%B4/","excerpt":"","text":"title: ‘[由于未初始化导致的本地运行和oj运行答案不一致]’date: 2019-11-19 17:08:22tags: 题目：本题要求实现一个函数，用下列公式求cos的近似值，精确到最后一项的绝对值小于e：cos(x)=x0/0!−x2/2!+x4/4!−x6/6!+⋯函数接口定义：double funcos( double e, double x );其中用户传入的参数为误差上限e和自变量x；函数funcos应返回用给定公式计算出来、并且满足误差要求的cos的近似值。输入输出均在双精度范围内。错误代码： #include &lt;stdio.h&gt;#include &lt;math.h&gt; double funcos( double e, double x ){ double s=0,t; int i=0,j,flag=1; while(fabs(t)&gt;=e) { t=pow(x,i); for(j=1;j&lt;=i;j++) { t/=j; } s+=t*flag; flag=-flag; i+=2; } return s;} int main(){ double e, x; scanf(&quot;%lf %lf&quot;, &amp;e, &amp;x); printf(&quot;cos(%.2f) = %.6f\\n&quot;, x, funcos(e, x)); return 0;} 正确代码： #include &lt;stdio.h&gt;#include &lt;math.h&gt; double funcos( double e, double x ){ double s=0,t=0; int i=0,j,flag=1; while(fabs(t)&gt;=e) { t=pow(x,i); for(j=1;j&lt;=i;j++) { t/=j; } s+=t*flag; flag=-flag; i+=2; } return s;} int main(){ double e, x; scanf(&quot;%lf %lf&quot;, &amp;e, &amp;x); printf(&quot;cos(%.2f) = %.6f\\n&quot;, x, funcos(e, x)); return 0;} 分析：第一次错误代码再本地运行时能输出正确答案，当在oj上运行时却输出0.000000.而第二次与第一次的区别仅仅是将t赋值为0，第一次未赋值，在本地能输出是因为巧合，刚好t的值能进入循环，而在oj上却没有这种巧合，所以直接连循环都没有进入，直接输出s的初始值0.00000。","categories":[],"tags":[]},{"title":"除数，判断俩个数字的各个数字是否有重复的","slug":"除数，判断俩个数字的各个数字是否有重复的","date":"2019-11-11T12:39:26.343Z","updated":"2019-11-12T04:32:37.252Z","comments":true,"path":"2019/11/11/除数，判断俩个数字的各个数字是否有重复的/","link":"","permalink":"http://yoursite.com/2019/11/11/%E9%99%A4%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E4%BF%A9%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E5%90%84%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84/","excerpt":"","text":"title: ‘[除数，判断俩个数字的各个数字是否有重复的]’date: 2019-11-11 20:39:26tags: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int is(int x,int y) { int a[10]; int i=0,s=0; for(i=0;i&lt;10;i++)a[i]=0;//给数组初始化数值，很重要，一开始没有对就是因为未初始化。 for(i=0;i&lt;5;i++) { a[x%10]=1; a[y%10]=1; x/=10;y/=10; } for(i=0;i&lt;10;i++)s+=a[i]; if(s==10)return 1; return 0;}int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1234;i&lt;98765;i++){ if(is(i,i*n)==1)printf(&quot;%d/%d=%d\\n&quot;,i*n,i,n); if(i*n&gt;100000)break; } return 0;}","categories":[],"tags":[]},{"title":"有关字符串比较函数的拓展","slug":"有关字符串比较函数的拓展","date":"2019-11-10T07:52:48.290Z","updated":"2019-12-24T04:48:06.543Z","comments":true,"path":"2019/11/10/有关字符串比较函数的拓展/","link":"","permalink":"http://yoursite.com/2019/11/10/%E6%9C%89%E5%85%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%8B%93%E5%B1%95/","excerpt":"","text":"title: ‘[有关字符串比较函数的拓展的思考]’date: 2019-11-10 15:52:48tags:题目：如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。例如，abcabc以3为周期（注意，它也以6为周期）。 输入一个长度不超过80的字符串，输出其最小周期。 int bijiao(char s1[],int a,int b,char s2[],int c,int d) { int i,j; for(i=a,j=c;i&lt;=b,j&lt;=d;i++,j++) { if (s1[i]&lt;s2[j]||s1[i]&gt;s2[j]) return 0; } return 1; } //字符串比较函数，比较函数是否相同，此处不能直接用函数库里的比较字符串函数，因为这个 需要在一个字符串中比较其子字符串。 *** 作用：在一个字符串内部比较其不同的子字符串是否相同，而不是选取两个不同字符串进行比较。","categories":[],"tags":[]},{"title":"[对于多组输入且每个输入对应一个输出的结果]","slug":"对于多组输入且每个输入对应一个输出的结果","date":"2019-11-08T03:13:38.000Z","updated":"2019-11-08T14:30:39.699Z","comments":true,"path":"2019/11/08/对于多组输入且每个输入对应一个输出的结果/","link":"","permalink":"http://yoursite.com/2019/11/08/%E5%AF%B9%E4%BA%8E%E5%A4%9A%E7%BB%84%E8%BE%93%E5%85%A5%E4%B8%94%E6%AF%8F%E4%B8%AA%E8%BE%93%E5%85%A5%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E8%BE%93%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C/","excerpt":"","text":"题目：有多组输入(不超过1000组)，每组输入只有1行，包含两个整数l和r(1&lt;=l&lt;=r&lt;=100000)，表示区间范围。对于一个数字n，如果它是偶数则n=n/2，否则n=n3+1。对于一个区间[l,r]中的数字不停的使用如上操作，直到其等于1为止，问所需操作次数最多的一个数需要多少次操作？”输出：最多的次数为y。每组输入对应输出一行“Case #x: y”，x表示第几组数数据（从1开始编号），y表示结果。#include&lt;stdio.h&gt;//算数教室1int main(){ int a,b,max=0,j=1; while(scanf(“%d%d”,&amp;a,&amp;b)!=EOF){ for(int i=a;i&lt;=b;i++){ int flag=0,temp=i; while(temp!=1){ if(temp%2==0)temp/=2;//偶数 else temp=temp3+1;//奇数 flag++; } if(flag&gt;max)max=flag; } printf(&quot;Case #%d: %d\\n&quot;,j++,max); } return 0;#include&lt;stdio.h&gt;//算数教室2int main(){ int a,b,k=1,max; int tab[100001]; for(int i=1;i&lt;=100000;i++){ int flag=0,temp=i; while(temp!=1){ if(temp%2==0)temp/=2;//偶数 else temp=temp*3+1;//奇数 flag++; } tab[i]=flag; } while(scanf(“%d%d”,&amp;a,&amp;b)!=EOF){ max=0; for(int j=a;j&lt;=b;j++) if(tab[j]&gt;max)max=tab[j]; printf(“Case #%d: %d\\n”,k++,max); } return 0;}第一次的代码显示时间超限，改进后的第二个代码就没有这个问题了；第二次改进的思路：首先将1到100000的每一个数字所对应的次数算出来，存入一个对应大小的数组其中数字为数组的下标，数组存的值即为每个数字对应的运算次数，然后再根据题目的输入输出，查表求出输入的每一个数字所对应的结果，再根据题目所给的要求将这些值进行运算求解。","categories":[],"tags":[]},{"title":"[字符串相关题目]","slug":"字符串相关题目","date":"2019-11-04T14:14:55.000Z","updated":"2019-11-04T15:36:37.756Z","comments":true,"path":"2019/11/04/字符串相关题目/","link":"","permalink":"http://yoursite.com/2019/11/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/","excerpt":"","text":"第一块题目：题目描述编写一程序，用于统计从键盘输入的字符串中的元音字母（a，A，e，E，i，I，o，O，u，U）的个数。输入每行输入一字符串，串长不超过255。输出输出对应字符串中元音字母的个数。样例输入 Copyabcioefgaeioak akkkksd样例输出 Copy352（一开始对题目的输入输出要求理解错误，认为是先输入一堆数据后统一输出，如果这道题像我这样理解的话，则输入应该为一个二维数组，每一行是一个字符串，一行一行的进行计算）#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ char ch;int sum; while(scanf(“%c” , &amp;ch) != EOF)/一直输入直到题目所给文件的末尾，如果手动输入则用 ctrl+z手动结束/ { if(ch==’a’||ch==’A’||ch==’e’||ch==’E’||ch==’i’||ch==’I’||ch==’o’||ch==’O’||ch==’U’||ch==’u’) sum++; if(ch == ‘\\n’){printf(“%d\\n” , sum);sum=0;}//sum记得在每一行的开始清零。 } return 0;}（在看聪哥敲代码的过程中发现他每次都会在一些符号前后加空格，值得学习） 第二块scanf(%s):遇回车和空格结束。gets()；遇空格才结束。当输入为：a b c d时char c[100]; while(scanf(“%s”,c)!=EOF){ printf(“%s”,c); }输出为abcd。 char c[100]; while(gets(c)!=EOF){ printf(“%s”,c); }输出为a b c d。 第三块 对于输入一个值然后将其转化为另一个值，且不是用一个特殊的递归表达式将它计算出来，此时可 以定义一个常量数组，然后每个输入有在该常量数组里的对应的序号，然后用其序号输出。 例题： 把手放在键盘上时，稍不注意就会移动错一位，这样，Q会变成W，输入一个错位后敲出的字符串， 输出打字员本来想打的字符串。输入保证合法，如输入中不会出现 A 。 样例输入： O S, GOMR YPFSU/ 样例输出： I AM FINE TODAY.#include&lt;stdio.h&gt;char s[] ={ “`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;’ZXCVBNM,./“ }int main(){ int i ,c; while((c=getchar())!=EOF){ for (i=1; s[i]&amp;&amp; s[i]!=c;i++);//找错位之后的字符在常量表达表中的位置 if(s[i])putchar(s[i-1]);//如果找到，则输出它的前一个字符 else putchar(c); }}","categories":[],"tags":[]},{"title":"水仙花数","slug":"水仙花数","date":"2019-10-31T03:39:01.869Z","updated":"2019-10-31T04:19:59.337Z","comments":true,"path":"2019/10/31/水仙花数/","link":"","permalink":"http://yoursite.com/2019/10/31/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/","excerpt":"","text":"title: “水仙花数一直没有正确输出的原因”date: 2019-10-31 11:39:01tags:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ int i,s,a,b; for(i=100;i&lt;1000;i++){ b=i; s=0;//当循环嵌套的时候，在内层循环的开始都应该让判断条件初始化。 while(b){ a=b%10; //printf(“a=%d”,a); s=s+aaa; b=b/10; //printf(“b=%d”,b); } //printf(“s=%d\\n”,s); if(s==i){ printf(“%d\\n”,i); } } return 0;}","categories":[],"tags":[]},{"title":"“第一条”","slug":"“第一条”","date":"2019-10-30T14:12:54.430Z","updated":"2019-10-30T14:19:57.349Z","comments":true,"path":"2019/10/30/“第一条”/","link":"","permalink":"http://yoursite.com/2019/10/30/%E2%80%9C%E7%AC%AC%E4%B8%80%E6%9D%A1%E2%80%9D/","excerpt":"","text":"title: “第一条”date: 2019-10-30 22:12:54tags:#博客内容 这是我的第一条博客，在这里 先记录下由斌哥堂哥分享的有关整数求每个位上数的代码。 #include &lt;stdio.h&gt; int main (void) { long long int n; int i = 0, a[1000], j = 0, t = 0; scanf (“%I64d”,&amp;n); if(n==0) printf(“0 “); while (n) { a[j++] = n % 10; n /= 10; } for (i = j - 1; i &gt;= 0; i–) { printf (“%d,”,a[i]);/将一个整数一个个的通过对10取余和除等于10，依次得到整数的 最后一位数字，将其存入数组，当需要时通过数组的下标一个个取出 } return 0; } 希望下一次写blog时已经可以将它部署到github上了。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-30T03:56:53.252Z","updated":"2019-10-30T03:56:53.252Z","comments":true,"path":"2019/10/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}